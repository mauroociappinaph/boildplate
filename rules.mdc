---
description:
globs:
alwaysApply: true
---
#  Rulescursor para proyectos microSaaS de Mauro

Gu铆a completa de buenas pr谩cticas, estructura y convenciones para desarrollar proyectos modernos usando Next.js 14, Tailwind CSS, Express, Prisma, Zustand y herramientas asociadas. Su objetivo es garantizar escalabilidad, orden, rendimiento, mantenibilidad y colaboraci贸n fluida en productos tipo microSaaS.

---

## Navegaci贸n

- Agregar un 铆ndice (table of contents) al principio o usar herramientas que permitan saltar r谩pido a secciones mejora mucho la experiencia.


---

## 1. Stack y estructura general

- Utilizar Next.js 14 con App Router para el frontend, Tailwind CSS para estilos y schadcn/ui para componentes reutilizables.
- El backend debe desarrollarse con Express y Node.js, utilizando Prisma como ORM para gestionar la base de datos.
- La estructura de carpetas debe estar organizada por dominio funcional. Separar claramente UI, l贸gica, tipos, servicios, hooks y utilidades.
- No se deben dejar carpetas vac铆as. Si una carpeta no tiene uso real, debe eliminarse.
- Los archivos deben mantenerse por debajo de las 200 l铆neas para facilitar legibilidad, mantenimiento y modularizaci贸n.
- La l贸gica de negocio no debe mezclarse con la UI. Debe estar encapsulada en servicios, hooks o funciones auxiliares.
- Colores y tipograf铆as deben definirse como variables reutilizables para poder ser modificadas desde un 煤nico lugar.

---

## 2. Gesti贸n de base de datos con Prisma

- Los modelos deben definirse en el archivo schema.prisma siguiendo convenciones de nombres claras y consistentes.
- Usar migraciones para versionar cambios en la estructura de datos.
- Centralizar la instancia de Prisma Client para evitar m煤ltiples conexiones.
- Implementar validaciones estrictas antes de ejecutar cualquier operaci贸n sobre la base de datos.
- Optimizar las consultas utilizando select e include solo para los datos necesarios.
- Para operaciones m煤ltiples, utilizar transacciones para garantizar atomicidad.
- Documentar relaciones complejas directamente en el schema para facilitar el entendimiento del modelo.
- Implementar tests para cualquier l贸gica que involucre interacci贸n con la base de datos.

---

## 3. Linting y formateo

- Usar Prettier para mantener un formateo de c贸digo uniforme.
- ESLint debe configurarse con reglas estrictas que detecten errores comunes y aseguren buenas pr谩cticas.
- Eliminar todos los imports que no est茅n siendo utilizados para evitar c贸digo muerto.

---

## 4. Control de versiones

- Utilizar ramas para cada feature, fix o release. Nunca trabajar directamente en main.
- Los commits deben seguir la convenci贸n de Conventional Commits, usando prefijos como feat, fix, chore, docs, refactor o test.
- Los mensajes deben ser descriptivos y enfocados en el objetivo del cambio.

---

## 5. Testing

- Priorizar la cobertura de l贸gica cr铆tica con tests unitarios.
- Utilizar Jest o herramientas equivalentes para garantizar confiabilidad.
- Implementar pruebas end-to-end para flujos importantes de usuario.
- Automatizar la ejecuci贸n de pruebas como parte del proceso de integraci贸n continua.
- Mantener una cobertura m铆nima del 80% en las partes sensibles del sistema.

---

## 6. Manejo de estado

- Usar Zustand como librer铆a para manejar el estado global de la aplicaci贸n.
- Modularizar los stores por dominio o funcionalidad.
- Los datos pesados o sensibles deben ser cacheados para evitar recargas innecesarias.
- Sincronizar estos datos con el servidor mediante hooks personalizados.

---

## 7. Seguridad

- Las claves y secretos deben gestionarse mediante variables de entorno. Nunca deben subirse al repositorio.
- Validar todos los datos de entrada del usuario utilizando librer铆as como zod o joi.
- Verificar los permisos del usuario para cualquier operaci贸n sensible en el backend.
- Implementar HTTPS y otras pr谩cticas de seguridad comunes para proteger los datos y las comunicaciones.

---

## 8. Despliegue

- El despliegue se debe realizar en Vercel con una configuraci贸n est谩ndar.
- El proceso de CI/CD debe incluir ejecuci贸n de lint, tests y build antes del deploy.
- Las variables de entorno sensibles deben ser configuradas exclusivamente desde el panel de Vercel.
- Activar alertas autom谩ticas para detectar errores en producci贸n.
- Implementar un pipeline de integraci贸n continua dividido en tres etapas:

  1. **Validaci贸n**: Ejecutar lint, tests unitarios y build para asegurar calidad b谩sica del c贸digo.

  2. **QA**: Correr tests end-to-end en un ambiente de staging que simule producci贸n.

  3. **Despliegue gradual**:
     - Iniciar desplegando solo al 10% del tr谩fico.
     - Monitorear errores y m茅tricas clave en tiempo real.
     - Si no se detectan incidentes en los primeros 15 minutos, aumentar gradualmente hasta cubrir el 100% del tr谩fico.


---

## 9. Reutilizaci贸n de c贸digo

- Los componentes UI deben ser reutilizables y desacoplados de l贸gica de negocio.
- La l贸gica repetida debe extraerse a funciones auxiliares o helpers en carpetas como utils o lib.
- Evitar duplicaci贸n de c贸digo en todo el sistema.
- Documentar funciones y componentes importantes para facilitar su uso y mantenimiento.

---

## 10. Comunicaci贸n con APIs

- Usar axios u otra librer铆a personalizada para realizar llamadas HTTP.
- Manejar los errores globalmente y tambi茅n por cada endpoint, mostrando feedback 煤til al usuario.
- Implementar l贸gica de reintento o espera progresiva en llamadas cr铆ticas.
- Loguear los errores de red o API para poder monitorear comportamientos inusuales.

Implementar un servicio unificado para APIs con:
- Interceptores para:
  - Inyecci贸n autom谩tica de tokens
  - Manejo centralizado de errores
  - Transformaci贸n de datos
- Timeouts configurables por endpoint
- Cancelaci贸n de requests duplicados

---

## 11. Control de calidad con Husky

- Husky debe usarse para agregar hooks en Git que ejecuten validaciones autom谩ticas antes de cada commit o push.
- En el pre-commit se debe ejecutar lint y tests sobre los archivos modificados.
- El hook commit-msg debe validar que el mensaje siga la convenci贸n de commits.
- Esto asegura que solo c贸digo de calidad y bien documentado llegue al repositorio principal.

---

## 12. Navegaci贸n

- Usar el sistema de rutas de Next.js App Router y su componente Link para la navegaci贸n interna.
- En caso de optar por React Router, se debe justificar claramente en la documentaci贸n del proyecto.

---

## 13. Separaci贸n entre l贸gica y UI

- Toda l贸gica debe vivir en hooks o servicios. Los componentes UI deben limitarse al renderizado y manejo de props.
- Evitar incluir l贸gica de negocio o llamadas HTTP dentro de componentes visuales.

---

## 14. Tipos e interfaces

- Todos los tipos e interfaces deben definirse en la carpeta types.
- Para grandes proyectos, considerar subcarpetas por dominio o contexto (por ejemplo: tipos de API, UI, DB, etc.).

---

## 15. Constantes

- Las constantes globales deben agruparse en la carpeta constants.
- Se deben usar nombres descriptivos y evitar repetir valores est谩ticos dispersos por el c贸digo.

---

## 16. Im谩genes

- Las im谩genes deben cargarse utilizando el componente optimizado de Next.js.
- Aplicar pr谩cticas como lazy loading, uso de placeholders y definici贸n expl铆cita de tama帽o para mejorar el rendimiento.

---

## 17. Logs y monitoreo

- Centralizar el manejo de logs y errores tanto en backend como en frontend.
- Utilizar herramientas como Sentry o LogRocket para seguimiento en producci贸n.
- Configurar alertas para detectar errores autom谩ticamente en tiempo real.

---

## 18. Internacionalizaci贸n y accesibilidad

- Implementar soporte multilenguaje usando herramientas como next-i18next.
- Aplicar buenas pr谩cticas de accesibilidad: uso correcto de etiquetas HTML, roles, contraste adecuado y navegaci贸n por teclado.

---

## 19. Documentaci贸n

- Documentar las APIs mediante herramientas como Swagger o OpenAPI.
- Comentar tipos y servicios complejos para facilitar su uso.
- Mantener siempre actualizado el README del proyecto.
- Registrar en la documentaci贸n las decisiones t茅cnicas importantes.

---

## 20. Limpieza general

- Eliminar todo c贸digo no utilizado, incluyendo imports, funciones y componentes innecesarios.
- No dejar carpetas vac铆as en la estructura del proyecto.
- Identificar patrones repetidos y abstraerlos en funciones o helpers reutilizables.
- Mantener una estructura limpia, ordenada y clara para cualquier nuevo colaborador.

---

## 21. Hidrataci贸n y SEO

- Evitar errores de hidrataci贸n asegurando que el contenido renderizado del lado del servidor coincida con el del cliente.
- Utilizar useEffect 煤nicamente para l贸gica que no debe ejecutarse durante SSR.
- Optimizar el SEO utilizando metadatos, etiquetas sem谩nticas, renderizado est谩tico o din谩mico seg煤n la necesidad.

---

## 22. Variables globales de dise帽o

- Colores y tipograf铆as deben centralizarse como variables globales reutilizables.
- Estas variables deben definirse en tailwind.config.js o mediante CSS variables en el root del proyecto.
- Esto permite cambiar el aspecto visual del proyecto desde un 煤nico archivo.

---

## 23. Configuraci贸n de Cursor

- Habilitar la opci贸n de **"Shared Projects"** para permitir colaboraci贸n en tiempo real con otros desarrolladores.
- Configurar y mantener **snippets compartidos** para componentes UI repetitivos, funciones comunes y hooks est谩ndar.
- Usar la **Command Palette** (atajo K / Ctrl+K) para navegar r谩pidamente entre archivos, ejecutar comandos o acceder a configuraciones sin salir del flujo de trabajo.
- Aprovechar la funcionalidad de **AI Autocomplete** para acelerar la escritura de c贸digo, especialmente en funciones, tipados y estructuras repetidas.
- Personalizar los atajos de teclado y el tema visual para mejorar productividad y legibilidad.
- Activar herramientas de an谩lisis de c贸digo que ofrece Cursor, como detecci贸n de imports no usados, sugerencias de refactorizaci贸n y documentaci贸n autom谩tica.


## 24. Performance

- Implementar estrategias de **code splitting** para cargar solo el c贸digo necesario en cada vista o componente, reduciendo el tama帽o inicial del bundle.
- Optimizar los bundles minimizando dependencias innecesarias y aplicando t茅cnicas como tree shaking.
- Utilizar **prefetching** de rutas para mejorar la velocidad de navegaci贸n anticipando la carga de p谩ginas que el usuario probablemente visitar谩.
- Aplicar **caching estrat茅gico** tanto en cliente como servidor para evitar recargas y mejorar tiempos de respuesta.
- Medir y monitorear performance regularmente usando herramientas como Lighthouse o Web Vitals para detectar y corregir cuellos de botella.

## 25. Manejo de errores

- Implementar un patr贸n unificado para el manejo de errores tanto en frontend como en backend, asegurando consistencia en la captura y reporte.
- Utilizar **error boundaries** en React para capturar errores en el 谩rbol de componentes y evitar que toda la app se caiga.
- Crear un servicio centralizado de notificaci贸n y logging de errores para facilitar el monitoreo y diagn贸stico.
- Mostrar mensajes de error claros y amigables al usuario sin exponer detalles t茅cnicos sensibles.

## 26. Onboarding para nuevos desarrolladores

- Proveer un script autom谩tico (`setup.sh` o equivalente) que instale todas las dependencias y configure hooks y herramientas necesarias.
- Mantener un archivo `project-guide.md` donde se expliquen todas las convenciones y reglas espec铆ficas del proyecto.
- Incluir un video walkthrough o documentaci贸n audiovisual que explique la arquitectura general del proyecto y c贸mo arrancar.
- Proveer una lista clara y actualizada de los comandos esenciales para desarrollo, construcci贸n, testing y despliegue.

## 27. Consideraciones para Monorepo

- Para proyectos que escalen, considerar usar herramientas como Turborepo o Nx para gestionar m煤ltiples packages dentro del mismo repositorio.
- Sugerir una estructura organizada con carpetas principales como:
  - `/apps` para aplicaciones concretas (por ejemplo: web, api)
  - `/packages` para m贸dulos compartidos (por ejemplo: ui, utils, types)
- Esta estructura facilita el mantenimiento, despliegue y escalabilidad del proyecto.

---

## 28. Integraci贸n de IA en el desarrollo

- Configurar prompts compartidos para la generaci贸n de c贸digo asistida por IA, asegurando coherencia y calidad.
- Establecer est谩ndares claros para la revisi贸n y validaci贸n del c贸digo generado mediante IA.
- Definir una pol铆tica de uso responsable y eficiente del autocompletado y otras funcionalidades de IA para maximizar productividad sin comprometer la calidad.

## 29. Consideraciones espec铆ficas para MicroSaaS

- Implementar estrategias de **feature flags** para habilitar o deshabilitar funcionalidades de forma din谩mica sin desplegar nuevo c贸digo.
- Gestionar de manera eficiente per铆odos de prueba (trials) y suscripciones recurrentes para los usuarios.
- Integrar pasarelas de pago confiables y seguras que soporten diferentes m茅todos y monedas.
- Incorporar sistemas de anal铆tica espec铆ficos para SaaS, monitoreando uso de features, conversi贸n, churn y engagement para tomar decisiones informadas.

## 30. Manejo avanzado de variables de entorno

- Utilizar herramientas como dotenv-flow para gestionar m煤ltiples ambientes (desarrollo, staging, producci贸n) de forma sencilla.
- Validar las variables de entorno usando librer铆as como zod para garantizar que est茅n definidas y con el formato correcto antes de iniciar la aplicaci贸n.

---

## 31. Health Checks y monitoreo

- Implementar endpoints de salud (health checks) que permitan verificar el estado de los servicios y dependencias.
- Integrar sistemas de monitoreo que consulten estos endpoints para alertar sobre posibles fallos o degradaciones del servicio.


El endpoint `/health` debe verificar:
- Conexi贸n a base de datos
- Estado de servicios externos
- Uso de memoria/CPU
- Versi贸n actual del deployment
- Tiempo promedio de respuesta

1. Health Checks y monitoreo (ampliaci贸n)

Se recomienda monitorear las siguientes m茅tricas clave para mantener la salud y rendimiento del sistema:

| M茅trica             | Umbral de Alerta   | Herramienta Sugerida |
|---------------------|--------------------|----------------------|
| Tiempo de respuesta API | Mayor a 500 ms      | New Relic             |
| Errores 5xx         | M谩s del 1% por hora | Sentry                |
| Uso de CPU          | M谩s del 70%         | Datadog               |
| Cobertura de tests  | Menor al 80%        | Coveralls             |
| Tasa de conversi贸n  | Ca铆da del 30%       | Mixpanel              |

Estas m茅tricas deben ser configuradas con alertas autom谩ticas para detectar y actuar r谩pidamente ante posibles incidentes.

## 32. Versionado de API

- Definir una estrategia clara de versionado de API para permitir evoluci贸n sin romper integraciones.
- Usar versiones en rutas o en headers para distinguir cambios mayores, menores o parches.

---

## 33. Dockerizaci贸n

- Crear configuraciones para contenerizar la aplicaci贸n utilizando Docker.
- Definir archivos Docker Compose para orquestar servicios relacionados (base de datos, cache, backend, frontend).
- Asegurar que las im谩genes sean ligeras y que el proceso de construcci贸n sea reproducible y eficiente.



## 34. Auditor铆as Peri贸dicas

Programar revisiones t茅cnicas cada 2 meses para:
- **Actualizar dependencias**: Usar `npm outdated` y renovar paquetes
- **Optimizar bundles**: Analizar con `webpack-bundle-analyzer`
- **Revisar m茅tricas**:
  - Performance (Lighthouse)
  - Cobertura de tests
  - Deuda t茅cnica (SonarQube)
- **Refactorizar**:
  - Identificar componentes complejos
  - Eliminar c贸digo duplicado
  - Simplificar l贸gica enrevesada

  ## 35. Organizaci贸n y legibilidad del README

- Para mejorar la legibilidad del README, cuando una secci贸n sea muy larga o t茅cnica, es recomendable crear documentos separados que profundicen en ese tema (por ejemplo, un archivo dedicado para Docker, otro para Testing, etc.).
- En el README principal, se debe dejar una introducci贸n breve a la secci贸n y un enlace claro hacia el documento detallado correspondiente.
- Esto facilita la navegaci贸n, evita que el README se vuelva inmanejable y ayuda a nuevos colaboradores a encontrar r谩pidamente la informaci贸n que necesitan.

## 36. Checklist para revisi贸n de Pull Requests (PRs)

Antes de hacer merge de un PR, se debe verificar:

- Que todos los tests (unitarios y end-to-end) pasen correctamente.
- Que la cobertura de tests en los cambios realizados sea mayor al 80%.
- Que el c贸digo haya pasado linting sin errores ni warnings.
- Que todas las variables de entorno nuevas est茅n documentadas y configuradas.
- Que se mantenga compatibilidad con versiones anteriores cuando corresponda.
- Que la documentaci贸n relacionada est茅 actualizada y sea clara.


## 37. Configuraci贸n de `.gitignore` y archivos sensibles

- Es obligatorio mantener un archivo `.gitignore` bien configurado para evitar subir al repositorio archivos innecesarios, generados o sensibles.
- Asegurarse de ignorar siempre:
  - Dependencias (`node_modules/`)
  - Archivos de build (`.next/`, `dist/`, etc.)
  - Archivos de entorno (`.env`, `.env.local`, `.env.*`)
  - Logs y archivos temporales (`logs/`, `*.log`)
  - Configuraciones locales (`.vscode/`, `.DS_Store`, etc.)
- Nunca se deben subir claves API, tokens, credenciales u otros secretos. Estos deben estar gestionados mediante variables de entorno.
- Validar que el archivo `.gitignore` est茅 presente y actualizado en cada nuevo repo o clonaci贸n del proyecto.
